"""Obsidian integration tools for the LangGraph agent."""

from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Optional

import httpx
from langchain_core.tools import tool

OBSIDIAN_URL = os.getenv("OBSIDIAN_API_URL", "http://localhost:27123")
OBSIDIAN_TOKEN = os.getenv("OBSIDIAN_API_TOKEN", "")


def _get_headers() -> dict:
    """Get headers for Obsidian API requests."""
    headers = {"Content-Type": "application/json"}
    if OBSIDIAN_TOKEN:
        headers["Authorization"] = f"Bearer {OBSIDIAN_TOKEN}"
    return headers


@tool
def read_note(path: str) -> str:
    """Read a note from the Obsidian vault.

    Args:
        path: Relative path to the note (e.g., "Research/topic.md")

    Returns:
        Note content or error message
    """
    try:
        url = f"{OBSIDIAN_URL}/vault/{path}"
        response = httpx.get(url, headers=_get_headers(), timeout=10)
        if response.status_code == 200:
            return response.text
        elif response.status_code == 404:
            return f"Note not found: {path}"
        else:
            return f"Error reading note: {response.status_code}"
    except Exception as e:
        return f"Failed to connect to Obsidian: {e}"


@tool
def write_priorities(
    priorities_markdown: str,
    file_path: str = "Research_Priorities.md",
) -> str:
    """Write the priority list to Obsidian vault.

    Args:
        priorities_markdown: Markdown content for the priorities file
        file_path: Path in vault for the file (default: Research_Priorities.md)

    Returns:
        Success or error message
    """
    try:
        url = f"{OBSIDIAN_URL}/vault/{file_path}"
        response = httpx.put(
            url,
            headers=_get_headers(),
            content=priorities_markdown,
            timeout=10,
        )
        if response.status_code in (200, 201, 204):
            return f"Successfully wrote priorities to {file_path}"
        else:
            return f"Error writing to Obsidian: {response.status_code}"
    except Exception as e:
        return f"Failed to connect to Obsidian: {e}"


@tool
def search_notes(query: str, max_results: int = 10) -> str:
    """Search for notes in the Obsidian vault.

    Args:
        query: Search query
        max_results: Maximum number of results to return

    Returns:
        JSON array of matching note paths
    """
    try:
        url = f"{OBSIDIAN_URL}/search/simple/"
        params = {"query": query}
        response = httpx.post(
            url,
            headers=_get_headers(),
            params=params,
            timeout=10,
        )
        if response.status_code == 200:
            results = response.json()[:max_results]
            return json.dumps(results, indent=2)
        else:
            return f"Search failed: {response.status_code}"
    except Exception as e:
        return f"Failed to search Obsidian: {e}"


def format_priorities_markdown(priorities: list[dict]) -> str:
    """Format priorities as Obsidian-compatible markdown.

    Args:
        priorities: List of priority dicts from compute_priorities

    Returns:
        Formatted markdown string
    """
    now = datetime.now().isoformat()

    lines = [
        "---",
        "type: research-priority",
        f"generated: {now}",
        "---",
        "",
        "# Research Priorities",
        "",
        "> [!NOTE]",
        "> Auto-generated by questDiscov. Updated automatically.",
        "",
        "## Top Questions to Answer",
        "",
    ]

    for p in priorities:
        lines.extend([
            f"### {p['rank']}. {p['text']}",
            "",
            f"- **ID**: `{p['id']}`",
            f"- **Priority Score**: {p['priority_score']:.3f}",
            f"- **Entropy**: {p['entropy']:.2f}",
            f"- **Centrality**: {p['centrality']:.3f}",
            f"- **Blocks**: {p.get('blocking_count', 0)} questions",
            f"- **Why**: {p.get('explanation', 'N/A')}",
            "",
        ])

    return "\n".join(lines)


@tool
def sync_priorities_to_obsidian(top_n: int = 5) -> str:
    """Compute priorities and sync them to Obsidian.

    This is a convenience tool that:
    1. Computes current priorities
    2. Formats them as markdown
    3. Writes to Research_Priorities.md

    Args:
        top_n: Number of top priorities to sync

    Returns:
        Status message
    """
    # Import here to avoid circular dependency
    from .priority_tools import compute_priorities

    # Get priorities
    priorities_json = compute_priorities.invoke({"use_llm": False, "top_n": top_n})
    priorities = json.loads(priorities_json)

    if isinstance(priorities, dict) and "message" in priorities:
        return priorities["message"]

    # Format as markdown
    markdown = format_priorities_markdown(priorities)

    # Write to Obsidian
    result = write_priorities.invoke({
        "priorities_markdown": markdown,
        "file_path": "Research_Priorities.md",
    })

    return result
