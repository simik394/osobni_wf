---
- name: Add OBS Studio PPA
  apt_repository:
    repo: ppa:obsproject/obs-studio
    state: present
  become: true

- name: Install OBS Studio
  apt:
    name: obs-studio
    state: present
    update_cache: yes
  become: true

- name: Ensure user plugins directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/plugins"
    state: directory
    mode: "0755"

- name: Check if Source Record plugin is already installed
  stat:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record/bin/64bit/source-record.so"
  register: plugin_so

- name: Install Source Record plugin
  block:
    - name: Create temporary directory for plugin
      tempfile:
        state: directory
        suffix: obs_plugin
      register: plugin_temp_dir

    - name: Download Source Record plugin zip
      get_url:
        url: "https://github.com/Exeldro/obs-source-record/releases/download/0.4.6/obs-source-record-0.4.6-linux-x86_64.zip"
        dest: "{{ plugin_temp_dir.path }}/source-record.zip"

    - name: Unarchive zip (contains tar.gz inside)
      unarchive:
        src: "{{ plugin_temp_dir.path }}/source-record.zip"
        dest: "{{ plugin_temp_dir.path }}"
        remote_src: yes

    - name: Find the tar.gz file inside the extracted zip
      find:
        paths: "{{ plugin_temp_dir.path }}"
        patterns: "*.tar.gz"
      register: found_tarball

    - name: Extract the tar.gz archive
      unarchive:
        src: "{{ found_tarball.files[0].path }}"
        dest: "{{ plugin_temp_dir.path }}"
        remote_src: yes
      when: found_tarball.files | length > 0

    - name: Create plugin directory structure
      file:
        path: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record"
        state: directory
        mode: "0755"

    - name: Copy plugin bin directory
      copy:
        src: "{{ plugin_temp_dir.path }}/bin/"
        dest: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record/bin/"
        mode: "0755"
        remote_src: yes

    - name: Copy plugin data directory
      copy:
        src: "{{ plugin_temp_dir.path }}/data/"
        dest: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record/data/"
        mode: "0644"
        remote_src: yes

    - name: Clean up temporary directory
      file:
        path: "{{ plugin_temp_dir.path }}"
        state: absent
  when: not plugin_so.stat.exists

# ============================================
# DATETIME LUA SCRIPT FOR DIGITAL CLOCK OVERLAY
# ============================================

- name: Ensure user scripts directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/scripts"
    state: directory
    mode: "0755"

- name: Download datetime Lua script for digital clock overlay
  get_url:
    url: "https://raw.githubusercontent.com/Kershoc/obs-script-datetime/refs/heads/master/DateTimeMultiple.lua"
    dest: "{{ ansible_env.HOME }}/.config/obs-studio/scripts/DateTimeMultiple.lua"
    mode: "0644"

# ============================================
# ONE-CLICK RECORDING AUTOMATION
# ============================================

- name: Create obs-record script (start/stop with cleanup)
  copy:
    dest: "{{ ansible_env.HOME }}/bin/obs-record"
    mode: "0755"
    content: |
      #!/bin/bash
      # OBS Studio Recording Controller
      # Usage: obs-record start|stop|status

      OBS_OUTPUT_DIR="{{ obs_recording_path }}"

      case "$1" in
        start)
          if pgrep -x obs > /dev/null; then
            echo "OBS is already running. Use 'obs-record stop' first."
            exit 1
          fi
          echo "Starting OBS recording..."
          obs --startrecording --minimize-to-tray &
          sleep 2
          echo "✓ Recording started. OBS is in system tray."
          echo "  Use 'obs-record stop' to stop recording."
          ;;
        
        stop)
          if ! pgrep -x obs > /dev/null; then
            echo "OBS is not running."
            exit 1
          fi
          echo "Stopping OBS..."
          # Send quit signal to OBS (stops recording first)
          pkill -SIGTERM obs
          sleep 3
          
          # Cleanup: delete dummy main output files (tiny files < 5MB without hdmi_/notebook_ prefix)
          echo "Cleaning up dummy files..."
          find "$OBS_OUTPUT_DIR" -name "*.mkv" -size -5M ! -name "hdmi_*" ! -name "notebook_*" -mmin -60 -delete 2>/dev/null
          
          echo "✓ Recording stopped and cleaned up."
          echo "  Files saved to: $OBS_OUTPUT_DIR"
          ls -lh "$OBS_OUTPUT_DIR"/*.mkv 2>/dev/null | tail -5
          ;;
        
        status)
          if pgrep -x obs > /dev/null; then
            echo "OBS is running (PID: $(pgrep -x obs))"
          else
            echo "OBS is not running."
          fi
          ;;
        
        *)
          echo "Usage: obs-record {start|stop|status}"
          echo ""
          echo "Commands:"
          echo "  start   - Launch OBS and start recording"
          echo "  stop    - Stop recording, close OBS, cleanup dummy files"
          echo "  status  - Check if OBS is running"
          exit 1
          ;;
      esac

- name: Create legacy start_recording.sh (backward compatibility)
  copy:
    dest: "{{ ansible_env.HOME }}/bin/start_recording.sh"
    mode: "0755"
    content: |
      #!/bin/bash
      # Legacy wrapper - use 'obs-record start' instead
      exec obs-record start

- name: Ensure ~/bin is in PATH (add to .bashrc if not present)
  lineinfile:
    path: "{{ ansible_env.HOME }}/.bashrc"
    line: 'export PATH="$HOME/bin:$PATH"'
    state: present
    create: yes

- name: Create desktop shortcut for OBS Recording
  copy:
    dest: "{{ ansible_env.HOME }}/.local/share/applications/obs-recording.desktop"
    mode: "0644"
    content: |
      [Desktop Entry]
      Version=1.0
      Type=Application
      Name=OBS Recording
      Comment=Start OBS with recording active
      Exec={{ ansible_env.HOME }}/bin/start_recording.sh
      Icon=com.obsproject.Studio
      Terminal=false
      Categories=AudioVideo;Recorder;
      StartupNotify=false

# ============================================
# OBS PROFILE CONFIGURATION (DUMMY OUTPUT)
# ============================================

- name: Ensure OBS profiles directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/basic/profiles/{{ obs_profile_name }}"
    state: directory
    mode: "0755"

- name: Ensure recording output directory exists
  file:
    path: "{{ obs_recording_path }}"
    state: directory
    mode: "0755"

- name: Deploy OBS profile with dummy output settings
  template:
    src: basic.ini.j2
    dest: "{{ ansible_env.HOME }}/.config/obs-studio/basic/profiles/{{ obs_profile_name }}/basic.ini"
    mode: "0644"
    backup: yes

# ============================================
# OBS SCENE COLLECTION (SOURCES & FILTERS)
# ============================================

- name: Ensure OBS scenes directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/basic/scenes"
    state: directory
    mode: "0755"

- name: Deploy OBS scene collection with sources and filters
  template:
    src: scenes.json.j2
    dest: "{{ ansible_env.HOME }}/.config/obs-studio/basic/scenes/{{ obs_scene_collection_name }}.json"
    mode: "0644"
    backup: yes

# ============================================
# SCREENSHOT RECORDING (LOW FPS ALTERNATIVE)
# ============================================

- name: Install imagemagick for screenshot recording
  apt:
    name:
      - imagemagick
      - xdotool
      - ffmpeg
    state: present
  become: true

- name: Create screenshot-record script
  copy:
    dest: "{{ ansible_env.HOME }}/bin/screenshot-record"
    mode: "0755"
    content: |
      #!/bin/bash
      # Adaptive screenshot recording with activity detection and auto-splitting
      # Usage: screenshot-record start|stop|status
      # 
      # Active (mouse/window change): 2s interval
      # Idle (no activity): 10s interval
      # Auto-split: Every 1 hour (creates separate MKV files)

      SCREENSHOT_DIR="{{ ansible_env.HOME }}/Videos/Screenshots"
      RECORDING_DIR="{{ obs_recording_path }}"
      INTERVAL_ACTIVE=2   # seconds when active
      INTERVAL_IDLE=10    # seconds when idle
      IDLE_THRESHOLD=30   # seconds of no activity before going idle
      CHUNK_DURATION=3600 # 1 hour in seconds
      PIDFILE="/tmp/screenshot-record.pid"

      # Configuration
      ENABLE_SOUND="false"  # Set to "true" to enable shutter sound

      convert_session() {
          local S_DIR="$1"
          local OUTPUT_NAME="screenshots_$(basename $S_DIR).mkv"
          local OUTPUT_PATH="$RECORDING_DIR/$OUTPUT_NAME"
          
          if [ -d "$S_DIR" ]; then
              # Rename files to sequential order for ffmpeg
              cd "$S_DIR"
              local i=0
              for f in $(ls -tr frame_*.png 2>/dev/null); do
                  mv "$f" "seq_$(printf '%05d' $i).png" 2>/dev/null
                  i=$((i + 1))
              done
              cd - > /dev/null
              
              local COUNT=$(ls "$S_DIR"/seq_*.png 2>/dev/null | wc -l)
              
              if [ "$COUNT" -gt 0 ]; then
                  # Framerate 0.5 means 1 frame lasts 2 seconds
                  ffmpeg -y -framerate 0.5 -i "$S_DIR/seq_%05d.png" \
                    -c:v libx264 -preset veryfast -crf 23 \
                    -pix_fmt yuv420p "$OUTPUT_PATH" > /dev/null 2>&1
                  
                  if [ -f "$OUTPUT_PATH" ]; then
                      rm -rf "$S_DIR"
                  fi
              fi
          fi
      }
      export -f convert_session
      export RECORDING_DIR

      case "$1" in
        start)
          if [ -f "$PIDFILE" ] && kill -0 "$(cat $PIDFILE)" 2>/dev/null; then
             echo "Screenshot recording is already running."
             exit 1
          fi
          
          # Initialize session
          START_TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
          SESSION_DIR="$SCREENSHOT_DIR/$START_TIMESTAMP"
          mkdir -p "$SESSION_DIR"
          
          # Configure sound
          SILENT_FLAG="-silent"
          if [ "$ENABLE_SOUND" = "true" ]; then
              SILENT_FLAG=""
          fi
          
          echo "Starting adaptive screenshot recording..."
          echo "  Auto-split: Every $(($CHUNK_DURATION / 60)) minutes"
          echo "  Sound: $ENABLE_SOUND"
          echo "  Output: $SESSION_DIR"
          
          (
            COUNT=0
            LAST_MOUSE=""
            LAST_WINDOW=""
            LAST_ACTIVITY=$(date +%s)
            CHUNK_START=$(date +%s)
            
            CURRENT_SESSION_DIR="$SESSION_DIR"
            
            while true; do
              # Check for chunk rotation
              NOW=$(date +%s)
              ELAPSED=$((NOW - CHUNK_START))
              
              if [ $ELAPSED -ge $CHUNK_DURATION ]; then
                  # Rotate chunk
                  OLD_SESSION_DIR="$CURRENT_SESSION_DIR"
                  NEW_TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
                  CURRENT_SESSION_DIR="$SCREENSHOT_DIR/$NEW_TIMESTAMP"
                  mkdir -p "$CURRENT_SESSION_DIR"
                  
                  # Reset counters for new chunk
                  COUNT=0
                  CHUNK_START=$NOW
                  
                  # Process old chunk in background
                  ( convert_session "$OLD_SESSION_DIR" ) &
                  
                  # Update session tracker
                  echo "$CURRENT_SESSION_DIR" > /tmp/screenshot-session.txt
              fi

              # Activity Detection
              CURRENT_MOUSE=$(xdotool getmouselocation 2>/dev/null | cut -d' ' -f1-2)
              CURRENT_WINDOW=$(xdotool getactivewindow 2>/dev/null)
              
              if [ "$CURRENT_MOUSE" != "$LAST_MOUSE" ] || [ "$CURRENT_WINDOW" != "$LAST_WINDOW" ]; then
                LAST_ACTIVITY=$NOW
                INTERVAL=$INTERVAL_ACTIVE
              else
                IDLE_TIME=$((NOW - LAST_ACTIVITY))
                if [ $IDLE_TIME -ge $IDLE_THRESHOLD ]; then
                  INTERVAL=$INTERVAL_IDLE
                else
                  INTERVAL=$INTERVAL_ACTIVE
                fi
              fi
              
              LAST_MOUSE="$CURRENT_MOUSE"
              LAST_WINDOW="$CURRENT_WINDOW"
              
              # Capture logic: Pipe import -> convert
              TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
              OUTPUT_FILE="$CURRENT_SESSION_DIR/frame_$(printf '%05d' $COUNT).png"
              
              # import to STDOUT (png:-), convert adds text, writes to file
              import $SILENT_FLAG -window root png:- 2>/dev/null | \
              convert png:- \
                -pointsize 40 \
                -fill white -stroke black -strokewidth 2 \
                -draw "gravity NorthWest text 50,1030 '$TIMESTAMP'" \
                -draw "gravity NorthWest text 1950,750 '$TIMESTAMP'" \
                "$OUTPUT_FILE"
                
              COUNT=$((COUNT + 1))
              
              sleep $INTERVAL
            done
          ) &
          
          PID=$!
          echo $PID > "$PIDFILE"
          echo "$SESSION_DIR" > /tmp/screenshot-session.txt
          echo "✓ Recording started (PID: $PID)"
          ;;
        
        stop)
          if [ ! -f "$PIDFILE" ]; then
            echo "No screenshot recording is running."
            exit 1
          fi
          
          PID=$(cat "$PIDFILE")
          # Get current session dir before killing
          SESSION_DIR=$(cat /tmp/screenshot-session.txt 2>/dev/null)
          
          echo "Stopping screenshot recording..."
          kill "$PID" 2>/dev/null
          rm -f "$PIDFILE"
          
          # Wait for any background conversions

          wait
          
          # Convert the final unfinished chunk
          if [ -n "$SESSION_DIR" ] && [ -d "$SESSION_DIR" ]; then
              echo "  Converting final session..."
              convert_session "$SESSION_DIR"
              echo "✓ Done."
          fi
          rm -f /tmp/screenshot-session.txt
          ;;
          
        status)
           if [ -f "$PIDFILE" ] && kill -0 "$(cat $PIDFILE)" 2>/dev/null; then
             echo "Running (PID: $(cat $PIDFILE))"
           else
             echo "Not running."
           fi
           ;;
           
        *)
           echo "Usage: screenshot-record {start|stop|status}"
           exit 1
           ;;
      esac

# ============================================
# SCREENSHOT RECORD SYSTEMD SERVICE (AUTO-START)
# ============================================

- name: Ensure user systemd directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/systemd/user"
    state: directory
    mode: "0755"

- name: Create screenshot-record systemd service
  copy:
    dest: "{{ ansible_env.HOME }}/.config/systemd/user/screenshot-record.service"
    mode: "0644"
    content: |
      [Unit]
      Description=Screenshot Record Service
      After=graphical-session.target
      PartOf=graphical-session.target

      [Service]
      Type=forking
      ExecStart={{ ansible_env.HOME }}/bin/screenshot-record start
      ExecStop={{ ansible_env.HOME }}/bin/screenshot-record stop
      PIDFile=/tmp/screenshot-record.pid
      Restart=on-failure
      RestartSec=5
      TimeoutStopSec=300
      Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:{{ ansible_env.HOME }}/bin
      Environment=DISPLAY=:1
      Environment=XAUTHORITY=/run/user/{{ ansible_user_uid }}/gdm/Xauthority

      [Install]
      WantedBy=graphical-session.target
  notify: Reload systemd user daemon

- name: Enable screenshot-record service
  systemd:
    name: screenshot-record.service
    scope: user
    enabled: yes
    daemon_reload: yes
