---
- name: Add OBS Studio PPA
  apt_repository:
    repo: ppa:obsproject/obs-studio
    state: present
  become: true

- name: Install OBS Studio
  apt:
    name: obs-studio
    state: present
    update_cache: yes
  become: true

- name: Ensure user plugins directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/plugins"
    state: directory
    mode: "0755"

- name: Check if Source Record plugin is already installed
  stat:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record/bin/64bit/source-record.so"
  register: plugin_so

- name: Install Source Record plugin
  block:
    - name: Create temporary directory for plugin
      tempfile:
        state: directory
        suffix: obs_plugin
      register: plugin_temp_dir

    - name: Download Source Record plugin zip
      get_url:
        url: "https://github.com/Exeldro/obs-source-record/releases/download/0.4.6/obs-source-record-0.4.6-linux-x86_64.zip"
        dest: "{{ plugin_temp_dir.path }}/source-record.zip"

    - name: Unarchive zip (contains tar.gz inside)
      unarchive:
        src: "{{ plugin_temp_dir.path }}/source-record.zip"
        dest: "{{ plugin_temp_dir.path }}"
        remote_src: yes

    - name: Find the tar.gz file inside the extracted zip
      find:
        paths: "{{ plugin_temp_dir.path }}"
        patterns: "*.tar.gz"
      register: found_tarball

    - name: Extract the tar.gz archive
      unarchive:
        src: "{{ found_tarball.files[0].path }}"
        dest: "{{ plugin_temp_dir.path }}"
        remote_src: yes
      when: found_tarball.files | length > 0

    - name: Create plugin directory structure
      file:
        path: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record"
        state: directory
        mode: "0755"

    - name: Copy plugin bin directory
      copy:
        src: "{{ plugin_temp_dir.path }}/bin/"
        dest: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record/bin/"
        mode: "0755"
        remote_src: yes

    - name: Copy plugin data directory
      copy:
        src: "{{ plugin_temp_dir.path }}/data/"
        dest: "{{ ansible_env.HOME }}/.config/obs-studio/plugins/source-record/data/"
        mode: "0644"
        remote_src: yes

    - name: Clean up temporary directory
      file:
        path: "{{ plugin_temp_dir.path }}"
        state: absent
  when: not plugin_so.stat.exists

# ============================================
# DATETIME LUA SCRIPT FOR DIGITAL CLOCK OVERLAY
# ============================================

- name: Ensure user scripts directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/scripts"
    state: directory
    mode: "0755"

- name: Download datetime Lua script for digital clock overlay
  get_url:
    url: "https://raw.githubusercontent.com/Kershoc/obs-script-datetime/refs/heads/master/DateTimeMultiple.lua"
    dest: "{{ ansible_env.HOME }}/.config/obs-studio/scripts/DateTimeMultiple.lua"
    mode: "0644"

# ============================================
# ONE-CLICK RECORDING AUTOMATION
# ============================================

- name: Create obs-record script (start/stop with cleanup)
  copy:
    dest: "{{ ansible_env.HOME }}/bin/obs-record"
    mode: "0755"
    content: |
      #!/bin/bash
      # OBS Studio Recording Controller
      # Usage: obs-record start|stop|status

      OBS_OUTPUT_DIR="{{ obs_recording_path }}"

      case "$1" in
        start)
          if pgrep -x obs > /dev/null; then
            echo "OBS is already running. Use 'obs-record stop' first."
            exit 1
          fi
          echo "Starting OBS recording..."
          obs --startrecording --minimize-to-tray &
          sleep 2
          echo "✓ Recording started. OBS is in system tray."
          echo "  Use 'obs-record stop' to stop recording."
          ;;
        
        stop)
          if ! pgrep -x obs > /dev/null; then
            echo "OBS is not running."
            exit 1
          fi
          echo "Stopping OBS..."
          # Send quit signal to OBS (stops recording first)
          pkill -SIGTERM obs
          sleep 3
          
          # Cleanup: delete dummy main output files (tiny files < 5MB without hdmi_/notebook_ prefix)
          echo "Cleaning up dummy files..."
          find "$OBS_OUTPUT_DIR" -name "*.mkv" -size -5M ! -name "hdmi_*" ! -name "notebook_*" -mmin -60 -delete 2>/dev/null
          
          echo "✓ Recording stopped and cleaned up."
          echo "  Files saved to: $OBS_OUTPUT_DIR"
          ls -lh "$OBS_OUTPUT_DIR"/*.mkv 2>/dev/null | tail -5
          ;;
        
        status)
          if pgrep -x obs > /dev/null; then
            echo "OBS is running (PID: $(pgrep -x obs))"
          else
            echo "OBS is not running."
          fi
          ;;
        
        *)
          echo "Usage: obs-record {start|stop|status}"
          echo ""
          echo "Commands:"
          echo "  start   - Launch OBS and start recording"
          echo "  stop    - Stop recording, close OBS, cleanup dummy files"
          echo "  status  - Check if OBS is running"
          exit 1
          ;;
      esac

- name: Create legacy start_recording.sh (backward compatibility)
  copy:
    dest: "{{ ansible_env.HOME }}/bin/start_recording.sh"
    mode: "0755"
    content: |
      #!/bin/bash
      # Legacy wrapper - use 'obs-record start' instead
      exec obs-record start

- name: Ensure ~/bin is in PATH (add to .bashrc if not present)
  lineinfile:
    path: "{{ ansible_env.HOME }}/.bashrc"
    line: 'export PATH="$HOME/bin:$PATH"'
    state: present
    create: yes

- name: Create desktop shortcut for OBS Recording
  copy:
    dest: "{{ ansible_env.HOME }}/.local/share/applications/obs-recording.desktop"
    mode: "0644"
    content: |
      [Desktop Entry]
      Version=1.0
      Type=Application
      Name=OBS Recording
      Comment=Start OBS with recording active
      Exec={{ ansible_env.HOME }}/bin/start_recording.sh
      Icon=com.obsproject.Studio
      Terminal=false
      Categories=AudioVideo;Recorder;
      StartupNotify=false

# ============================================
# OBS PROFILE CONFIGURATION (DUMMY OUTPUT)
# ============================================

- name: Ensure OBS profiles directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/basic/profiles/{{ obs_profile_name }}"
    state: directory
    mode: "0755"

- name: Ensure recording output directory exists
  file:
    path: "{{ obs_recording_path }}"
    state: directory
    mode: "0755"

- name: Deploy OBS profile with dummy output settings
  template:
    src: basic.ini.j2
    dest: "{{ ansible_env.HOME }}/.config/obs-studio/basic/profiles/{{ obs_profile_name }}/basic.ini"
    mode: "0644"
    backup: yes

# ============================================
# OBS SCENE COLLECTION (SOURCES & FILTERS)
# ============================================

- name: Ensure OBS scenes directory exists
  file:
    path: "{{ ansible_env.HOME }}/.config/obs-studio/basic/scenes"
    state: directory
    mode: "0755"

- name: Deploy OBS scene collection with sources and filters
  template:
    src: scenes.json.j2
    dest: "{{ ansible_env.HOME }}/.config/obs-studio/basic/scenes/{{ obs_scene_collection_name }}.json"
    mode: "0644"
    backup: yes

# ============================================
# SCREENSHOT RECORDING (LOW FPS ALTERNATIVE)
# ============================================

- name: Install scrot for screenshot recording
  apt:
    name:
      - scrot
      - ffmpeg
    state: present
  become: true

- name: Create screenshot-record script
  copy:
    dest: "{{ ansible_env.HOME }}/bin/screenshot-record"
    mode: "0755"
    content: |
      #!/bin/bash
      # Adaptive screenshot recording with activity detection
      # Usage: screenshot-record start|stop|status
      # 
      # Active (mouse/window change): 2s interval
      # Idle (no activity): 10s interval

      SCREENSHOT_DIR="{{ ansible_env.HOME }}/Videos/Screenshots"
      INTERVAL_ACTIVE=2   # seconds when active
      INTERVAL_IDLE=10    # seconds when idle
      IDLE_THRESHOLD=30   # seconds of no activity before going idle
      PIDFILE="/tmp/screenshot-record.pid"

      case "$1" in
        start)
          if [ -f "$PIDFILE" ] && kill -0 "$(cat $PIDFILE)" 2>/dev/null; then
            echo "Screenshot recording is already running (PID: $(cat $PIDFILE))"
            exit 1
          fi
          
          # Create session directory with timestamp
          SESSION_DIR="$SCREENSHOT_DIR/$(date +%Y-%m-%d_%H-%M-%S)"
          mkdir -p "$SESSION_DIR"
          
          echo "Starting adaptive screenshot recording..."
          echo "  Active interval: ${INTERVAL_ACTIVE}s"
          echo "  Idle interval: ${INTERVAL_IDLE}s"
          echo "  Idle threshold: ${IDLE_THRESHOLD}s"
          echo "  Output: $SESSION_DIR"
          
          # Start background screenshot loop with activity detection
          (
            COUNT=0
            LAST_MOUSE=""
            LAST_WINDOW=""
            LAST_ACTIVITY=$(date +%s)
            
            while true; do
              # Get current state
              CURRENT_MOUSE=$(xdotool getmouselocation 2>/dev/null | cut -d' ' -f1-2)
              CURRENT_WINDOW=$(xdotool getactivewindow 2>/dev/null)
              NOW=$(date +%s)
              
              # Check for activity
              if [ "$CURRENT_MOUSE" != "$LAST_MOUSE" ] || [ "$CURRENT_WINDOW" != "$LAST_WINDOW" ]; then
                LAST_ACTIVITY=$NOW
                INTERVAL=$INTERVAL_ACTIVE
              else
                IDLE_TIME=$((NOW - LAST_ACTIVITY))
                if [ $IDLE_TIME -ge $IDLE_THRESHOLD ]; then
                  INTERVAL=$INTERVAL_IDLE
                else
                  INTERVAL=$INTERVAL_ACTIVE
                fi
              fi
              
              LAST_MOUSE="$CURRENT_MOUSE"
              LAST_WINDOW="$CURRENT_WINDOW"
              
              # Take screenshot
              scrot -m "$SESSION_DIR/frame_${COUNT}.png" 2>/dev/null
              COUNT=$((COUNT + 1))
              
              sleep $INTERVAL
            done
          ) &
          
          echo $! > "$PIDFILE"
          echo "$SESSION_DIR" > /tmp/screenshot-session.txt
          echo "✓ Recording started (PID: $!)"
          echo "  Use 'screenshot-record stop' to stop and convert to video."
          ;;
        
        stop)
          if [ ! -f "$PIDFILE" ]; then
            echo "No screenshot recording is running."
            exit 1
          fi
          
          PID=$(cat "$PIDFILE")
          SESSION_DIR=$(cat /tmp/screenshot-session.txt 2>/dev/null)
          
          echo "Stopping screenshot recording..."
          kill "$PID" 2>/dev/null
          # Kill child processes too
          pkill -P "$PID" 2>/dev/null
          rm -f "$PIDFILE"
          
          if [ -n "$SESSION_DIR" ] && [ -d "$SESSION_DIR" ]; then
            # Rename files to sequential order for ffmpeg
            echo "  Renaming files..."
            cd "$SESSION_DIR"
            i=0
            for f in $(ls -t frame_*.png 2>/dev/null | tac); do
              mv "$f" "seq_$(printf '%05d' $i).png" 2>/dev/null
              i=$((i + 1))
            done
            cd - > /dev/null
            
            COUNT=$(ls "$SESSION_DIR"/seq_*.png 2>/dev/null | wc -l)
            echo "  Captured $COUNT frames"
            
            if [ "$COUNT" -gt 0 ]; then
              echo "  Converting to video (this may take a moment)..."
              OUTPUT="{{ obs_recording_path }}/screenshots_$(basename $SESSION_DIR).mkv"
              
              # Use variable framerate - calculate average FPS from session
              START_TIME=$(basename "$SESSION_DIR" | sed 's/_/ /g' | head -c19)
              
              ffmpeg -y -framerate 1 -pattern_type glob -i "$SESSION_DIR/seq_*.png" \
                -c:v libx264 -preset veryfast -crf 23 \
                -pix_fmt yuv420p -vf "fps=1" "$OUTPUT" 2>/dev/null
              
              if [ -f "$OUTPUT" ]; then
                SIZE=$(du -h "$OUTPUT" | cut -f1)
                echo "✓ Video saved: $OUTPUT ($SIZE)"
                echo "  Cleaning up PNG files..."
                rm -rf "$SESSION_DIR"
              else
                echo "✗ Video conversion failed. PNG files kept in: $SESSION_DIR"
              fi
            fi
          fi
          rm -f /tmp/screenshot-session.txt
          ;;
        
        status)
          if [ -f "$PIDFILE" ] && kill -0 "$(cat $PIDFILE)" 2>/dev/null; then
            SESSION_DIR=$(cat /tmp/screenshot-session.txt 2>/dev/null)
            COUNT=$(ls "$SESSION_DIR"/frame_*.png 2>/dev/null | wc -l)
            echo "Screenshot recording is running (PID: $(cat $PIDFILE))"
            echo "  Frames captured: $COUNT"
            echo "  Output: $SESSION_DIR"
          else
            echo "Screenshot recording is not running."
          fi
          ;;
        
        *)
          echo "Usage: screenshot-record {start|stop|status}"
          echo ""
          echo "Adaptive screenshot recording with activity detection"
          echo ""
          echo "Intervals:"
          echo "  Active (mouse/window change): 2 seconds"
          echo "  Idle (no activity for 30s):   10 seconds"
          echo ""
          echo "Commands:"
          echo "  start   - Start adaptive screenshot recording"
          echo "  stop    - Stop and convert to MKV video"
          echo "  status  - Check recording status and frame count"
          exit 1
          ;;
      esac
